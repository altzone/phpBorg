#!/bin/bash
#
# phpBorg Installation - Frontend Build
# Builds Vue.js frontend application
#

#
# Install npm dependencies
#

install_npm_dependencies() {
    print_section "Installing Frontend Dependencies"

    local frontend_dir="${PHPBORG_ROOT}/frontend"

    # Check if frontend directory exists
    if [ ! -d "${frontend_dir}" ]; then
        log_error "Frontend directory not found: ${frontend_dir}"
        return 1
    fi

    # Check if package.json exists
    if [ ! -f "${frontend_dir}/package.json" ]; then
        log_error "package.json not found in ${frontend_dir}"
        return 1
    fi

    cd "${frontend_dir}" || return 1

    # Check if node_modules already exists
    if [ -d "node_modules" ] && [ "${INSTALL_MODE}" = "interactive" ]; then
        if ! confirm "node_modules exists. Reinstall dependencies?" "n"; then
            log_info "Skipping npm install"
            save_state "install_npm_dependencies" "completed"
            return 0
        fi
    fi

    # Run npm install
    log_info "Running npm install (this may take several minutes)..."

    # Must cd first, then source NVM to ensure proper PATH
    if su - phpborg -c "cd ${frontend_dir} && source ~/.nvm/nvm.sh && npm install --legacy-peer-deps" >> "${INSTALL_LOG}" 2>&1; then
        log_success "Frontend dependencies installed"
        save_state "install_npm_dependencies" "completed"
        return 0
    else
        log_error "Failed to install frontend dependencies"
        log_error "Check if NVM is properly installed for phpborg user"
        return 1
    fi
}

#
# Configure frontend environment
#

configure_frontend_env() {
    print_section "Configuring Frontend Environment"

    local frontend_dir="${PHPBORG_ROOT}/frontend"
    local env_file="${frontend_dir}/.env.production"

    cd "${frontend_dir}" || return 1

    # Get API URL
    local api_url="http://${DOMAIN}"
    if [ "${DOMAIN}" = "localhost" ]; then
        api_url="http://localhost"
    fi

    # Prompt for API URL in interactive mode
    if [ "${INSTALL_MODE}" = "interactive" ]; then
        prompt "API URL (without /api suffix)" "${api_url}" api_url
    fi

    # Create .env.production file
    log_info "Creating frontend environment file"

    cat > "${env_file}" <<EOF
# Frontend Production Configuration
# Generated by installer on $(date '+%Y-%m-%d %H:%M:%S')

VITE_API_URL=${api_url}
VITE_APP_NAME=phpBorg
VITE_APP_VERSION=1.0.0
EOF

    if [ $? -eq 0 ]; then
        chown phpborg:phpborg "${env_file}"
        log_success "Frontend environment configured"
        save_state "configure_frontend_env" "completed"
        return 0
    else
        log_error "Failed to create frontend environment file"
        return 1
    fi
}

#
# Build frontend for production
#

build_frontend() {
    print_section "Building Frontend Application"

    local frontend_dir="${PHPBORG_ROOT}/frontend"

    cd "${frontend_dir}" || return 1

    # Check if already built
    if [ -d "dist" ] && [ "${INSTALL_MODE}" = "interactive" ]; then
        if ! confirm "Frontend already built. Rebuild?" "y"; then
            log_info "Skipping frontend build"
            save_state "build_frontend" "completed"
            return 0
        fi
    fi

    # Run build
    log_info "Building frontend (this may take several minutes)..."
    echo -e "${YELLOW}Please wait...${NC}"

    # Show spinner in background
    (
        while true; do
            for spin in '⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏'; do
                echo -ne "\r${CYAN}${spin}${NC} Building frontend..."
                sleep 0.1
            done
        done
    ) &
    local spinner_pid=$!

    # Run build as phpborg user
    # Use npx to ensure vite is found in node_modules/.bin
    su - phpborg -c "cd ${frontend_dir} && source ~/.nvm/nvm.sh && npx vite build" >> "${INSTALL_LOG}" 2>&1
    local build_result=$?

    # Stop spinner
    kill "${spinner_pid}" 2>/dev/null
    wait "${spinner_pid}" 2>/dev/null
    echo -ne "\r"

    if [ ${build_result} -eq 0 ]; then
        log_success "Frontend built successfully"
        save_state "build_frontend" "completed"
        return 0
    else
        log_error "Frontend build failed"
        return 1
    fi
}

#
# Deploy frontend to public directory
#

deploy_frontend() {
    print_section "Deploying Frontend"

    local frontend_dir="${PHPBORG_ROOT}/frontend"
    local dist_dir="${frontend_dir}/dist"
    local public_dir="${PHPBORG_ROOT}/public"

    # Check if dist directory exists
    if [ ! -d "${dist_dir}" ]; then
        log_error "Frontend dist directory not found: ${dist_dir}"
        return 1
    fi

    # Backup existing public directory
    if [ -d "${public_dir}" ]; then
        backup_dir "${public_dir}"
        log_info "Existing public directory backed up"
    fi

    # Create public directory if needed
    mkdir -p "${public_dir}"

    # Copy built files
    log_info "Copying frontend files to public directory"

    # Copy all files from dist to public
    if cp -r "${dist_dir}"/* "${public_dir}/"; then
        # Set correct ownership
        chown -R phpborg:phpborg "${public_dir}"
        chmod -R 755 "${public_dir}"

        log_success "Frontend deployed to ${public_dir}"
        save_state "deploy_frontend" "completed"
        return 0
    else
        log_error "Failed to deploy frontend"
        return 1
    fi
}


#
# Verify frontend deployment
#

verify_frontend() {
    print_section "Verifying Frontend Deployment"

    local public_dir="${PHPBORG_ROOT}/public"
    local index_html="${public_dir}/index.html"

    # Check if index.html exists
    if [ ! -f "${index_html}" ]; then
        log_error "index.html not found in public directory"
        return 1
    fi

    # Check if assets directory exists
    if [ ! -d "${public_dir}/assets" ]; then
        log_warn "assets directory not found (may not be required)"
    fi

    # Check file permissions
    if [ ! -r "${index_html}" ]; then
        log_error "index.html is not readable"
        return 1
    fi

    log_success "Frontend deployment verified"
    save_state "verify_frontend" "completed"
    return 0
}

#
# Clean up build artifacts
#

cleanup_build() {
    print_section "Cleaning Up Build Artifacts"

    local frontend_dir="${PHPBORG_ROOT}/frontend"

    cd "${frontend_dir}" || return 0

    if [ "${INSTALL_MODE}" = "interactive" ]; then
        if confirm "Remove node_modules to save space?" "n"; then
            log_info "Removing node_modules"
            rm -rf node_modules
            log_success "node_modules removed"
        else
            log_info "Keeping node_modules for future builds"
        fi
    else
        log_info "Keeping node_modules (auto mode)"
    fi

    save_state "cleanup_build" "completed"
    return 0
}

#
# Main frontend setup orchestrator
#

setup_frontend() {
    print_header "Frontend Setup"

    local errors=0

    # Install npm dependencies
    if ! is_step_completed "install_npm_dependencies"; then
        install_npm_dependencies || errors=$((errors + 1))
    else
        log_info "npm dependencies already installed (skipped)"
    fi

    # Configure frontend environment
    if ! is_step_completed "configure_frontend_env"; then
        configure_frontend_env || errors=$((errors + 1))
    else
        log_info "Frontend environment already configured (skipped)"
    fi

    # Build frontend
    if ! is_step_completed "build_frontend"; then
        build_frontend || errors=$((errors + 1))
    else
        log_info "Frontend already built (skipped)"
    fi

    # Deploy frontend
    if ! is_step_completed "deploy_frontend"; then
        deploy_frontend || errors=$((errors + 1))
    else
        log_info "Frontend already deployed (skipped)"
    fi

    # Verify deployment
    if ! is_step_completed "verify_frontend"; then
        verify_frontend || errors=$((errors + 1))
    else
        log_info "Frontend already verified (skipped)"
    fi

    # Cleanup (optional)
    if ! is_step_completed "cleanup_build"; then
        cleanup_build || errors=$((errors + 1))
    else
        log_info "Build cleanup already done (skipped)"
    fi

    if [ ${errors} -eq 0 ]; then
        log_success "Frontend setup completed successfully"
        save_state "frontend_setup" "completed"
        return 0
    else
        log_error "Frontend setup completed with ${errors} error(s)"
        return 1
    fi
}
